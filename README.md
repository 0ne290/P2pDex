# Короче, надо действовать радикально: ВСЕ Singleton-зависимости должны быть ПОЛНОСТЬЮ потокобезопасными, чтобы не *#@!% себе мозги лишними размышлениями "А будет ли тут состояние гонки или нет?"

## UPD: Отмена по абзацу выше - найдено и внедрено лучшее решение

# Выбрасывать исключения при нарушении бизнес-инвариантов в моделях слоя Domain и НЕ отлавливать их. Идея в том, что нарушения бизнес-инвариантов это CriticalError и вообще харам, а все ошибочные кейсы должны отлавливаться и обрабатываться в валидаторах команд слоя Application

# Меняем политику комиссий: теперь перед всей солью фронтенд должен делать запрос на создание _запроса_ на создание заказа на продажу. В ответ на это бэкенд должен прислать размер комиссии и адрес кошелька биржи. Далее фронтенд должен обеспечить перевод с кошелька клиента на кошелек биржи кол-ва крипты, равного сумме комиссии, полученной от бэкенда и кол-ва продаваемой крипты, указанной продавцом в заказе

# Вероятно, подробные сообщения нужно делать не для возвращаемых клиенту ошибок, а для логирования с уровнями Debug, Info и Warning. Примеры не подробного и подробного сообщения, соответственно: "Trader does not exists.", $"Trader with guid \"{traderGuid}\" does not exists.". В Debug уровень должно логироваться, например, "Class.Method called by parameters {param1}, {param2}, {param3}." и "Class.Method returned {returnedObject}.". В Info уровень всякие изменения в состоянии системы, например, "Trader {trader} created." (под "created" подразумевается добавление в БД). В Warnging всякие маловероятные события, продиктованные внешними факторами, но которые не ломают систему и все-таки ожидаются например, "Blockchain canceled the transaction". В Error всякие неперехваченные контроллерами / обработчиками команд исключения, которые влияют только на один запрос и не ломают весь бэкенд, например, деление на ноль после построения хоста. В Fatal все то, что ломает бэкенд целиком, например, исключения до построения хоста.
